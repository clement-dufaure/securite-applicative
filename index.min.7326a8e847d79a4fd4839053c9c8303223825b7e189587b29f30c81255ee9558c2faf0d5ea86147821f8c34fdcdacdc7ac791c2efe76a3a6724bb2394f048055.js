var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(n){const s=suggestions.classList.contains("d-none");if(s)return;const e=[...suggestions.querySelectorAll("a")];if(e.length===0)return;const t=e.indexOf(document.activeElement);if(n.key==="ArrowUp"){n.preventDefault();const s=t>0?t-1:0;e[s].focus()}else if(n.key==="ArrowDown"){n.preventDefault();const s=t+1<e.length?t+1:t;e[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/authentification/",title:"Authentification",description:"",content:""}).add({id:1,href:"/docs/authentification/principes/",title:"Les grands principes de l'authentification",description:"3 # Authentification # Qu\u0026rsquo;est qu\u0026rsquo;une personne authentifiée #  Une personne connue de l\u0026rsquo;application Elle est donc enregistrée Comment stocker cette information ? Type de base de donnée dédiée : l\u0026rsquo;annuaire  Qu\u0026rsquo;est que l\u0026rsquo;authentification #  Validation d\u0026rsquo;une identification Un utilisateur doit indiquer qui il est (identifiant, certificat client) et le prouver (mot de passe, certifcat client, carte à puce, code à usage unique, empreinte digitale) Au moins un facteur, mais plusieurs facteurs simultanés améliorent la preuve (mot de passe + carte à puce)  Le SSO - Single Sign On #  S\u0026rsquo;identifier une seule fois pour accéder à plusieurs services Système d\u0026rsquo;authentification centralisé Question du SLO  Logout = déconnexion de l\u0026rsquo;application uniquement ?",content:"3 # Authentification # Qu\u0026rsquo;est qu\u0026rsquo;une personne authentifiée #  Une personne connue de l\u0026rsquo;application Elle est donc enregistrée Comment stocker cette information ? Type de base de donnée dédiée : l\u0026rsquo;annuaire  Qu\u0026rsquo;est que l\u0026rsquo;authentification #  Validation d\u0026rsquo;une identification Un utilisateur doit indiquer qui il est (identifiant, certificat client) et le prouver (mot de passe, certifcat client, carte à puce, code à usage unique, empreinte digitale) Au moins un facteur, mais plusieurs facteurs simultanés améliorent la preuve (mot de passe + carte à puce)  Le SSO - Single Sign On #  S\u0026rsquo;identifier une seule fois pour accéder à plusieurs services Système d\u0026rsquo;authentification centralisé Question du SLO  Logout = déconnexion de l\u0026rsquo;application uniquement ? Ou déconnexion de l\u0026rsquo;application et du fournisseur d\u0026rsquo;identité ? Ou encore, de l\u0026rsquo;application, du fournisseur, et de toutes les autres applis s\u0026rsquo;étant connectées via le fournisseur ?    Annuaire # Référentiel permettant de stocker des données de manière hiérarchique et offrant des mécanismes pour rechercher efficacement l\u0026rsquo;information.\n Recensement des informations sur les utilisateurs, sur les applications, sur un parc informatique Authentifier un utilisateur Donner un droit d\u0026rsquo;un objet sur un autre, gestion de groupes (hierarchie)  Technologies d\u0026rsquo;annuaires #  OpenLDAP : projet opensource Active Directory (AD) : solution Microsoft.  Ressource authentifié # Les besoins d\u0026rsquo;authentification sont variés.\nUne application peut proposer :\n Du contenu public (donc sans authentification) Du contenu accessible à n\u0026rsquo;importe quel utilisateur authentifié Du contenu accessible à certains utilisateurs  Ressource authentifié #  Authentification explicite : je présente un en-tête \u0026ldquo;Authorization\u0026rdquo; dans ma requête Authentification implicite : je m\u0026rsquo;attends à ce que l\u0026rsquo;application me donne un moyen de m\u0026rsquo;authentifier  Ressource authentifié # En arrivant sur une page où je suis censé être authentifié\n Je présente un header \u0026ldquo;Authorization\u0026rdquo; ? Si oui et que l\u0026rsquo;application l\u0026rsquo;accepte je suis authentifié Sinon, l\u0026rsquo;application peut me proposer des moyens de m\u0026rsquo;authentifier S\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;autres moyens que le header Authorization ou que j\u0026rsquo;ai déjà tenté tous les modes possibles sans succès, je reçois définitivement une erreur 401 \u0026ldquo;Unauthorized\u0026rdquo;  Ressource authentifié # Si un ou plusieurs autre modes de connexion sont disponibles, les fonctionnements sont variés :\n 401 + WWW-Authenticate header : le navigateur doit savoir réagir 200 + traitements divers ou 30X : redirection vers page de login ou vers un fournisseur d\u0026rsquo;identité  Ressource authentifié #  Exemple : l\u0026rsquo;authentification Basic  Authorization: Basic Base64(identifiant:motdepasse)   Si un site propose l\u0026rsquo;authentification Basic, et que l\u0026rsquo;on vient sans l\u0026rsquo;entête authorisation, le site répond avec l\u0026rsquo;entête :  WWW-Authenticate: Basic realm=\u0026quot;nom d'affichage\u0026quot;   Le navigateur voyant cet entête affiche à l\u0026rsquo;utilisateur une pop-up demandant un identifiant et mot de passe et ayant pour titre le \u0026ldquo;nom d\u0026rsquo;affichage\u0026rdquo; Le navigateur utilisera ce couple identifiant mot de passe pour former l\u0026rsquo;en-tête Authorisation tout le reste de la session  Ressource authentifié # Je suis correctement identifié mais la ressource ne s\u0026rsquo;adresse qu\u0026rsquo;à un certain type d\u0026rsquo;utilisateur dont je ne fais pas partie :\n Erreur 403 Forbidden  Rappel code réponse HTTP : #  20X : succès 30X : redirection 40X : erreur côté Client Web 50X : erreur côté Serveur Web  Rappel code réponse HTTP : #  200 : OK 301 : Moved Permanently 302 : Found (Déplacé temporairement) 400 : Bad Request 401 : Unauthorized 403 : Forbidden 404 : Not Found 418 : I’m a teapot (RFC 2324) 500 : Internal Server Error 503 : Service Unavailable : réponse fournie par un reverse proxy si l\u0026rsquo;application n\u0026rsquo;est pas disponible (maintenance par exemple)  Rappel code réponse HTTP : # 401 ou 403 ?\n 401 : Unauthorized : L\u0026rsquo;authentification ne s\u0026rsquo;est pas dérolée comme prévue ou elle s\u0026rsquo;est bien déroulée mais l\u0026rsquo;utilisateur est inconnu de l\u0026rsquo;application 403 : Forbidden : L\u0026rsquo;authentification s\u0026rsquo;est bien déroulée et l\u0026rsquo;utilisateur est connu mais il n\u0026rsquo;a pas les habilitations nécessaires  Comment savoir si l\u0026rsquo;utilisateur a les droits ? # Le mode d\u0026rsquo;authentification peut simplement présenter une identifiation. C\u0026rsquo;est alors à moi de déterminer si l\u0026rsquo;utilisateur a le droit d\u0026rsquo;accéder à la ressource et d\u0026rsquo;afficher les bonnes informations.\nM Robichu se connecte à mon questionnaire en ligne.\nIl a pu s\u0026rsquo;authentifier correctement sur l\u0026rsquo;application, la seule information connue de l\u0026rsquo;application est alors son identifiant.\nL\u0026rsquo;application recherche en base de données l\u0026rsquo;identifiant de M Robichu et récupère bien une ligne qui contient notamment les informations déjà renseignées par M Robichu.\nJe sais donc que M Robichu a les droits sur l\u0026rsquo;application et je peux en plus préremplir le questionnaire avec ce que je sais déjà\nComment savoir si l\u0026rsquo;utilisateur a les droits ? # Le mode d\u0026rsquo;authentification peut fournir une réponse plus complète contenant des rôles. Je peux alors me servir de ces rôles récupérés pour gérer l\u0026rsquo;accès à mes ressources.\nM Robichu se connecte à mon questionnaire en ligne.\n*Il a pu s\u0026rsquo;authentifier correctement sur l\u0026rsquo;application, les informations connues de l\u0026rsquo;application sont maintenant son identifiant mais aussi une liste de rôles dont \u0026ldquo;repondant-enquete-satisfaction-joint-etancheite-climatiseur-morgue\u0026rdquo;. *\nJe sais directement que M Robichu a les droits sur l\u0026rsquo;application. Mais rien ne m\u0026rsquo;empêche de chercher en base de données des informations plus précises sur M Robichu\nComment savoir si l\u0026rsquo;utilisateur a les droits ? # Rôles dans l\u0026rsquo;authentification ou en base de données ?\nSe limiter au rôles le plus brut possible dans le système d\u0026rsquo;authentification (répondant, administrateur)\nÉviter de trop spécifier le rôle surtout si l\u0026rsquo;on possède l\u0026rsquo;information en base de données. (répondant à l\u0026rsquo;enquête X, à l\u0026rsquo;enquête Y, etc.)\nQuelques exemples d\u0026rsquo;authentification # Authentifications directes :\n Basic Formulaire Certificat Client Kerberos : adapté au Web par SPNEGO, Simple and Protected GSSAPI (Generic Security Services Application Program Interface) Negotiation Mechanism, implémenté par AD NTLM (NT Lan Manager) : Systèmes Windows ou compatible AD  Authentifications centralisées nécessitant l\u0026rsquo;utilisation d\u0026rsquo;un autre mode :\n SAML OpenID Connect  Kerberos # WWW-Authenticate: Negociate\n Système d\u0026rsquo;échange de jeton basé sur des clés symétriques (déduites des mots de passes)  https://blog.devensys.com/kerberos-principe-de-fonctionnement/\nNTLM # Kerberos simplifié et moins sécurisé\nWWW-Authenticate: NegociateNTLM\n Envoi de l\u0026rsquo;identifiant Challenge du serveur, à résoudre avec le hash du mot de passe Le serveur demande à AD de valider (identifiant,challenge, réponse du client) AD répond au serveur si l\u0026rsquo;authentification est OK  Authentifications Kerberos ou NTLM : Sécurité #  Afin de contrôler ce flux, les sources autorisées à émettre une demande de challenge sont contrôlées Dans Firefox, il s\u0026rsquo;agit des propriétés suivantes (about:config)  network.negotiate-auth.delegation-uris : insee.intra,insee.fr,insee.test,insee.eu,localhost network.negotiate-auth.trusted-uris : insee.intra,insee.fr,insee.test,insee.eu,localhost network.automatic-ntlm-auth.trusted-uris :  Plus d\u0026rsquo;informations : https://developer.mozilla.org/en-US/docs/Mozilla/Integrated_authentication\nConfidentialité de l\u0026rsquo;authentification #  Kerberos, NTLM, SAML : Sécurité intrinsèque (même sur un canal en clair, une lecture réseau ne permet pas d\u0026rsquo;obtenir des informations sur les credentials de l\u0026rsquo;utilisateur) Certificat client : Étape du protocole HTTPS Formulaire, Basic, OIDC : Sécurité basée sur un canal chiffré (HTTPS)  Utilisation d\u0026rsquo;une fédération d\u0026rsquo;identité #  On verra le fonctionnement en détail plus tard (SAML, OpenIDConnect) Principe : déléguer l\u0026rsquo;authentification à un autre système (Kerberos et NTLM sont au fond des fédérations d\u0026rsquo;identité) Intérêts :  Authentification centralisée Éviter les accès directs aux annuaires SSO Amélioration de la sécurité : la sécurité est également déléguée au protocole et au système authentifiant, reduction de la surface d\u0026rsquo;attaque Cependant la sécurité du client reste à la charge des applications    "}).add({id:2,href:"/docs/https/",title:"Https",description:"",content:""}).add({id:3,href:"/docs/failles/",title:"Failles applicatives",description:"",content:""}).add({id:4,href:"/docs/intro/",title:"Introduction",description:"",content:""}).add({id:5,href:"/docs/intro/grands-principes/",title:"Les grands principes de la sécurité",description:"Qu\u0026rsquo;est ce que \u0026ldquo;la sécurité infromatique\u0026rdquo; ??\nou De quoi va-t-on parler ?\nDes grands principes (nombre et portée variant selon les sources)\n Disponibilité Intégrité Confidentialité Authentification Traçabilité Non répudiation   La première partie de cette formation présentera des failles applicatives pouvant impacter un ou plusieurs de ces principes.\n Disponibilité #  S\u0026rsquo;assurer que les utilisateurs peuvent accéder au service sur les plages d\u0026rsquo;utilisation prévues et en respectant des temps de réponse attendus Du ressort des ops\u0026hellip;  Haute disponibilité via plusieurs couloirs (scalabilité horizontale) Ajutement mémoire/CPU (scalabilité verticale) Supervision   \u0026hellip; et des devs  Penser les limites de chaque traitement, contraindre l\u0026rsquo;utilisateur Éviter les traitements saturant la machines en une requête\u0026hellip; Suivre les mises à jour des librairies    Intégrité #  S\u0026rsquo;assurer que l\u0026rsquo;information envoyée à l\u0026rsquo;utilisateur est celle qu\u0026rsquo;il reçoit Solutions pour considérations techniques (réseau perturbé, perte de paquet, \u0026hellip;)  Ajout de mécanismes de controles : TCP avec numéro de séquence et checksum Notions de fonctions de hachage   MAIS : ne permet pas de se prémunir d\u0026rsquo;une altération volontaire des données par un attaquant  Ajouter un hash\u0026hellip; mais non modifiable facilement\u0026hellip; donc ne transitant pas en clair    Confidentialité #  S\u0026rsquo;assurer que seul l\u0026rsquo;emmetteur et le récepteur d\u0026rsquo;une information peuvent la consulter S\u0026rsquo;assurer de l\u0026rsquo;identité du serveur distant Nécessité de chiffrer les données TLS surchargé aux principaux protocoles (HTTPS, FTPS, etc.",content:"Qu\u0026rsquo;est ce que \u0026ldquo;la sécurité infromatique\u0026rdquo; ??\nou De quoi va-t-on parler ?\nDes grands principes (nombre et portée variant selon les sources)\n Disponibilité Intégrité Confidentialité Authentification Traçabilité Non répudiation   La première partie de cette formation présentera des failles applicatives pouvant impacter un ou plusieurs de ces principes.\n Disponibilité #  S\u0026rsquo;assurer que les utilisateurs peuvent accéder au service sur les plages d\u0026rsquo;utilisation prévues et en respectant des temps de réponse attendus Du ressort des ops\u0026hellip;  Haute disponibilité via plusieurs couloirs (scalabilité horizontale) Ajutement mémoire/CPU (scalabilité verticale) Supervision   \u0026hellip; et des devs  Penser les limites de chaque traitement, contraindre l\u0026rsquo;utilisateur Éviter les traitements saturant la machines en une requête\u0026hellip; Suivre les mises à jour des librairies    Intégrité #  S\u0026rsquo;assurer que l\u0026rsquo;information envoyée à l\u0026rsquo;utilisateur est celle qu\u0026rsquo;il reçoit Solutions pour considérations techniques (réseau perturbé, perte de paquet, \u0026hellip;)  Ajout de mécanismes de controles : TCP avec numéro de séquence et checksum Notions de fonctions de hachage   MAIS : ne permet pas de se prémunir d\u0026rsquo;une altération volontaire des données par un attaquant  Ajouter un hash\u0026hellip; mais non modifiable facilement\u0026hellip; donc ne transitant pas en clair    Confidentialité #  S\u0026rsquo;assurer que seul l\u0026rsquo;emmetteur et le récepteur d\u0026rsquo;une information peuvent la consulter S\u0026rsquo;assurer de l\u0026rsquo;identité du serveur distant Nécessité de chiffrer les données TLS surchargé aux principaux protocoles (HTTPS, FTPS, etc.)  👉  L'intégrité est très difficilement dissociable de la confidentialité  Une appli sans HTTPS n'est plus envisageable aujourd'hui    Un kit de survie du HTTPS sera abordé dans la partie HTTPS de la formation. Il s\u0026rsquo;agit de connaitre les principes de base, afin de pouvoir apréhender les principales erreurs relative à une configuration HTTPS.\n Authentification #  Une opération n\u0026rsquo;est accessible qu\u0026rsquo;à ceux qui sont censé réaliser l\u0026rsquo;opération Prouver qu\u0026rsquo;on est celui qu\u0026rsquo;on déclare être  On parle de facteurs d\u0026rsquo;authentification pour chaque preuve que l\u0026rsquo;on peut aborder\n Ce que je sais : mot de passe Ce que je possède : certificat, carte à puce, badge Ce que je suis : empreinte digitale, rétinienne   Une grande partie de cette formation se focalise sur les enjeux et les moyens concret de mettre en place une authentification sur son application\n Traçabilité #  Être capable de savoir ce qui s\u0026rsquo;est passé sur un serveur et par qui Avoir un système de logs,\u0026hellip; Connaitre son sytème de logs !!! Avoirs des moyens efficace de rechercher une information dans ses logs   Ne sera pas abordé dans cette formation, mais reste une étape indispensable à la reflexion de la sécurité de son application. Le jour on aura besoin de savoir ce qu\u0026rsquo;il s\u0026rsquo;est passé, ce sera trop tard pour y penser\u0026hellip;\n Non répudiation #  Un utilisateur ne peut nier une action effectuée \u0026ldquo;Signature d\u0026rsquo;un contrat\u0026rdquo; Principe de la signature électronique   Hors scope de cette formation\n Pour aller plus loin #  Auto-formation aux grands concepts de la sécurité par l\u0026rsquo;ANSSI : https://www.secnumacademie.gouv.fr/  "}).add({id:6,href:"/docs/failles/intro/",title:"Qu'est ce qu'une faille applicative ?",description:"",content:""}).add({id:7,href:"/docs/failles/sql/",title:"Injections de code (serveur)",description:"",content:""}).add({id:8,href:"/docs/failles/injection-client/",title:"Injections de code (client)",description:"Encore des injections...",content:""}).add({id:9,href:"/docs/https/fonctionnement/",title:"Fontionnement de https",description:"2 # Mise en place de HTTPS #  Les grands principes # HTTPS intervient dans :\n Intégrité Confidentialité Authentification   Les grands principes #  HTTP protocole purement applicatif \u0026ldquo;Web\u0026rdquo; : toutes données échangées sont en clair Protocole SSL ou TLS (le nom dépend de la version) : gestion d\u0026rsquo;un tunnel sécurisé Des protocoles purement fonctionnels (HTTP,FTP,SMTP,\u0026hellip;) peuvent se sécuriser simplement en s\u0026rsquo;échangeant dans un tunnel SSL HTTPS = HTTP + SSL   Proposer HTTPS #  Avoir un listener dédié au HTTPS (sur le port 443 dans une configuration standard) : le HTTPS est \u0026ldquo;implicite\u0026rdquo; Avoir une configuration HTTPS minimale, soit un couple clé privée/clé publique   Echange sécurisé #  Les deux parties, client et serveur, doivent se mettre d\u0026rsquo;accord sur une clé symétrique Il existe des méthode pour communiquer sur un réseau en clair une clé symétrique secrète, qui sera en fait partiellement généré par les deux parties (Algorithme de Diffie-Hellman) A quoi sert la clé asymétrique alors ?",content:"2 # Mise en place de HTTPS #  Les grands principes # HTTPS intervient dans :\n Intégrité Confidentialité Authentification   Les grands principes #  HTTP protocole purement applicatif \u0026ldquo;Web\u0026rdquo; : toutes données échangées sont en clair Protocole SSL ou TLS (le nom dépend de la version) : gestion d\u0026rsquo;un tunnel sécurisé Des protocoles purement fonctionnels (HTTP,FTP,SMTP,\u0026hellip;) peuvent se sécuriser simplement en s\u0026rsquo;échangeant dans un tunnel SSL HTTPS = HTTP + SSL   Proposer HTTPS #  Avoir un listener dédié au HTTPS (sur le port 443 dans une configuration standard) : le HTTPS est \u0026ldquo;implicite\u0026rdquo; Avoir une configuration HTTPS minimale, soit un couple clé privée/clé publique   Echange sécurisé #  Les deux parties, client et serveur, doivent se mettre d\u0026rsquo;accord sur une clé symétrique Il existe des méthode pour communiquer sur un réseau en clair une clé symétrique secrète, qui sera en fait partiellement généré par les deux parties (Algorithme de Diffie-Hellman) A quoi sert la clé asymétrique alors ? Problème du \u0026ldquo;Man in the middle\u0026rdquo;    Confidentialité #  \u0026ldquo;Information invisible par un tiers\u0026rdquo;\u0026hellip; Encore faut il maîtriser les deux parties Le client doit savoir qui il est en train de contacter Le serveur propose un certificat contenant principalement son nom : l\u0026rsquo;url que l\u0026rsquo;utilisateur a demandé sa clé publique la signature de ces informations par une autorité de confiance   Autorité de confiance ? #  C\u0026rsquo;est un organisme qui signe avec sa clé privée les informations du serveur On peut donc vérifier avec la clé publique de l\u0026rsquo;AC si informations et signature correspondent Pour récupérer la clé publique de l\u0026rsquo;Autorité de confiance, on consulte son\u0026hellip; Certificat ! \u0026hellip; Mais comment vérifier son certificat ? Le certificat d\u0026rsquo;une AC est autosignée, le navigateur est configuré pour accepter un certain nombre L\u0026rsquo;insee est une AC reconnue en interne uniquement Les applis Internet sont signées par une AC externe reconnue dans le monde entier (intégrée sur les navigateurs connus)   La poignée de main, ou handshaking #  Le client fait une demande de transaction sécurisée au serveur Le serveur renvoie son certificat, contenant la clé publique Le client valide le certificat Le client génère une clé secrète qu\u0026rsquo;il chiffre avec la clé publique. La clé secrète est envoyée au serveur Le serveur déchiffre la clé secrète Cette clé est utilisée pour chiffrer les prochains échanges entre le client et le serveur   La poignée de main, ou handshaking #  Comment faire en local ? #  Il n\u0026rsquo;est pas nécessaire d\u0026rsquo;avoir un certificat signé par une autorité de confiance Un certificat autosigné suffit : c\u0026rsquo;est un certificat \u0026ldquo;localhost\u0026rdquo; signé par \u0026ldquo;localhost\u0026rdquo;   Génération d\u0026rsquo;un certificat autosigné # # On génère une clé privée openssl genrsa 2048 \u0026gt; server.key # On génère la clé publique associé à la clé privée, et on prépare la demande de certificat openssl req -new -key server.key -out server.csr \u0026gt; Country Name (2 letter code) [AU]:FR \u0026gt; State or Province Name (full name) [Some-State]:France \u0026gt; Locality Name (eg, city) []:Paris \u0026gt; Organization Name (eg, company) [Internet Widgits Pty Ltd]:Insee \u0026gt; Organizational Unit Name (eg, section) []:CNIP \u0026gt; Common Name (e.g. server FQDN or YOUR name) []:localhost \u0026gt; Email Address []: \u0026gt; Please enter the following 'extra' attributes \u0026gt; to be sent with your certificate request \u0026gt; A challenge password []: \u0026gt; An optional company name []: #On fait signer la demande par l'AC qui ici est localhost lui-même openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt #Si on veut transformer en keystore openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12 -passout pass:changeit   HTTPS en pratique #  L\u0026rsquo;application ne gère pas le HTTPS, c\u0026rsquo;est le serveur applicatif (tomcat) ou un équipement réseau supérieur qui en a la charge L\u0026rsquo;application peut imposer l\u0026rsquo;utilisation du HTTPS   HTTPS en pratique #  Dans tous les cas c\u0026rsquo;est le serveur applicatif (tomcat) qui a la charge de déterminer si la connexion entrante est sécurisée Cas direct : c\u0026rsquo;est tomcat qui gère lui même la connexion ssl Cas indirect : tomcat ne gère pas de connexion HTTPS mais il sait que la connexion initiale est en HTTPS (cas d\u0026rsquo;un reverse proxy) Si le connecteur gère la connexion ssl ou qu\u0026rsquo;il est dédié à recevoir des connexions sécurisées, on peut directement le spécifier sécurisé. Sinon, il va falloir définir un profil de requêtes sécurisées   HTTPS indirect en pratique : en production #  Architecture Load Balancer qui porte les certificats (et donc gère la connexion HTTPS) Le load balancer déchiffre et transmet une requête HTTP (en clair) au serveur applicatif portant l\u0026rsquo;application   HTTPS indirect en pratique : en production # Transfert de l\u0026rsquo;information HTTPS\n Pour savoir que la requête initiale est en HTTPS, le load balancer ajoute un entête \u0026ldquo;X-Forwarded-Proto: HTTPS\u0026rdquo;, et on configure Tomcat pour que la lecture de cet entête signifie sécurisé  \u0026lt;Valve className=\u0026quot;org.apache.catalina.connector.RemoteIpValve\u0026quot; protocolHeader=\u0026quot;X-Forwarded-Proto\u0026quot; /\u0026gt;  Une valve Tomcat est une classe exécutée (invoke()) à l\u0026rsquo;arrivée de chaque requête.\n HTTPS direct en pratique : sur localhost # Sur Tomcat\nDans server.xml :\n Ajout d\u0026rsquo;un connecteur SSL  \u0026lt;Connector port=\u0026quot;8443\u0026quot; protocol=\u0026quot;org.apache.coyote.http11.Http11NioProtocol\u0026quot; maxThreads=\u0026quot;150\u0026quot; SSLEnabled=\u0026quot;true\u0026quot; scheme=\u0026quot;https\u0026quot; secure=\u0026quot;true\u0026quot; clientAuth=\u0026quot;false\u0026quot; sslProtocol=\u0026quot;TLS\u0026quot; keystoreFile=\u0026quot;${catalina.home}/conf/ssl/server.p12\u0026quot; keystoreType=\u0026quot;pkcs12\u0026quot; keystorePass=\u0026quot;changeit\u0026quot; /\u0026gt;   HTTPS direct en pratique # Sur Tomcat\nDans server.xml\n Définition du port de redirection dans le cas d\u0026rsquo;un connecteur non sécurisé  \u0026lt;Connector connectionTimeout=\u0026quot;20000\u0026quot; port=\u0026quot;8080\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; redirectPort=\u0026quot;8443\u0026quot;/\u0026gt;   Sur l\u0026rsquo;appli, pour indiquer qu\u0026rsquo;on impose du https # web.xml (Tomcat)\n\u0026lt;security-constraint\u0026gt; \u0026lt;display-name\u0026gt;tout-en-https\u0026lt;/display-name\u0026gt; \u0026lt;web-resource-collection\u0026gt; \u0026lt;web-resource-name\u0026gt;tout\u0026lt;/web-resource-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/web-resource-collection\u0026gt; \u0026lt;user-data-constraint\u0026gt; \u0026lt;transport-guarantee\u0026gt;CONFIDENTIAL\u0026lt;/transport-guarantee\u0026gt; \u0026lt;/user-data-constraint\u0026gt; \u0026lt;/security-constraint\u0026gt;   Sur l\u0026rsquo;appli, pour indiquer qu\u0026rsquo;on impose du https # Spring Security\n@Configuration @EnableWebSecurity public class SpringSecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.requiresChannel().antMatchers(\u0026quot;/**\u0026quot;).requiresSecure(); } }   TP #  Générer un keystore pour une configuration https de localhost Mettre en place https sur un serveur local Forcer le https sur l\u0026rsquo;application   Vraiment forcer le HTTPS #  Niveau applicatif pour controle éventuellement Niveau Frontal (Load Balancer) : écouter en http sur le port 80 mais uniquement pour rediriger vers https Déclaratif Indiquer au navigateur de ne plsu utiliser que HTTPS : en-tête HSTS  Strict-Transport-Security \u0026quot;max-age=31536000\u0026quot;   Le truststore #  Mon application doit se connecter à une autre application (web-service) Je souhaite que cet appel soit en https (au fond justifié que si la connexion entre les deux serveurs passent par Internet) Lors d\u0026rsquo;une connexion HTTPS, Java vérifie si le certificat distant est valide C\u0026rsquo;est ce que fait le navigateur quand on se connecte à un site Si le certificat n\u0026rsquo;est pas valide (expiré, non associé au domaine, non signé par une autorité de confiance), le navigateur me le signale et je choisit de prendre le risque ou non de me connecter au site. Dans l\u0026rsquo;appli, Java refusera systématiquement la connexion   Le truststore #  Date d\u0026rsquo;expiration, mauvais nom : je ne peux rien faire, il faut que le certificat soit cohérent Autosigné ? Je peux dire à Java que le signataire du certificat est valide, en d\u0026rsquo;autres termes, je lui définis une autorité de confiance (Il existe la possibilité de créer une classe faisant que Java ne fait plus aucun contrôle sur le certificat mais c\u0026rsquo;est mal) Il faut créer un truststore contenant l\u0026rsquo;ensemble des certificats à valider (= ce que l\u0026rsquo;on considère AC)   Le truststore #  Par défaut le trustore chargé est celui de la jvm éxécutant l\u0026rsquo;application (\u0026hellip;.\\mon-jdk\\lib\\security\\cacerts) Le mot de passe par défaut est changeit On peut vouloir un \u0026ldquo;Insee flavored cacert\u0026rdquo; : le cacerts disponible dans la distribution java plus la chaine de certification Insee (AC Racine + AC Subordonnée) Au cas où : certificats AC Insee   Le truststore #  Pour le changer on utilise des paramètres de la JVM :  javax.net.ssl.trustStrore javax.net.ssl.trustStorePassword javax.net.ssl.trustStoreType (par défaut jks)   On crée un nouveau truststore, en pratique on ajoute nos certificats au truststore par défaut   Le truststore #  Créer le truststore  keytool -import -trustcacerts -file server.crt -alias localhost -keystore cacertsperso  Si keytool inconnu : (à ajouter au path pour plus de simplicité)\n\u0026quot;path/to/mon-jdk/bin/keytool.exe\u0026quot; \u0026quot;$JAVA_HOME/bin/keytool.exe\u0026quot;  Crée le truststore si cacertsperso n\u0026rsquo;existe pas encore, ajoute le certificat aux existants s\u0026rsquo;il existe déjà\n Le truststore #  Le déclarer au démarrage :  Paramètres de démarrage    -Djavax.net.ssl.trustStore=\u0026quot;/path/to/cacerts.jks\u0026quot; -Djavax.net.ssl.trustStorePassword=changeit -Djavax.net.ssl.trustStoreType=JKS -Djavax.net.debug=all (UNIQUEMENT pour debugger en cas de problème, c'est TRES verbeux)   Dans le code :  System.setProperty(\u0026quot;javax.net.ssl.trustStore\u0026quot;, \u0026quot;/path/to/cacerts.jks\u0026quot;); System.setProperty(\u0026quot;javax.net.ssl.trustStorePassword\u0026quot;, \u0026quot;changeit\u0026quot;); System.setProperty(\u0026quot;javax.net.ssl.trustStoreType\u0026quot;, \u0026quot;JKS\u0026quot;);   TP #  Créer un truststore incluant le cacert Insee et le certificat généré précédemment Le faire prendre en compte dans l\u0026rsquo;application   Https sur les application javascript #  Fonctionnement proche : réalisé par le F5 en prod, par l\u0026rsquo;apache en dv/qf (mais il n\u0026rsquo;y a pas de tomcat) L\u0026rsquo;application s\u0026rsquo;éxécute chez le client, pour forcer le https, il faut donc raisonner côté client Si l\u0026rsquo;application JS veut s\u0026rsquo;assurer de passer en HTTPS, elle doit vérifier le window.location du client et éventuellement le rediriger.   Https sur les application javascript # if ( typeof window !== 'undefined' \u0026amp;\u0026amp; window.location \u0026amp;\u0026amp; window.location.protocol === 'http:' ) { window.location.href = window.location.href.replace( /^http(?!s)/, 'https' ); }   Https sur les application javascript : développement # Pour lancer une application \u0026ldquo;create-react-app\u0026rdquo; en https en local (par defaut http) :\n Au lieu de npm start Lancer set HTTPS=true\u0026amp;\u0026amp;npm start   Https sur les application javascript : cas du back-end mal signé # Un front-end JavaScript effectue des appels à son backend.\nDans la pratique, c\u0026rsquo;est le navigateur qui effectue ces requetes, et si le certificat du backend ne convient pas au navigateur, la requete va être rejetée.\n Solution 1 : Faire en sort que le backend ait un certificat signé par l\u0026rsquo;Insee Solution 2 : se connecter manuellement une fois au backend, accepter l\u0026rsquo;alerte de sécurité du navigateur  "}).add({id:10,href:"/docs/https/pratique/",title:"Mise en pratique de https",description:"Générer un certificat # Les étapes :\n Générer une clé privée Calculer la clé publique à partir de la clé privée Enrober la clé publique dans une demande de certificat Signer la demande de certificat (facultatif) Générer le bon format d\u0026rsquo;échange  Qui signe ?\n Une autorité payante Let\u0026rsquo;s encrypt Nous-même dans le cadre de l\u0026rsquo;exercice ! Certifcat dit autosigné, ici généré pour localhost, signé par localhost  # On génère une clé privée openssl genrsa 2048 \u0026gt; server.",content:"Générer un certificat # Les étapes :\n Générer une clé privée Calculer la clé publique à partir de la clé privée Enrober la clé publique dans une demande de certificat Signer la demande de certificat (facultatif) Générer le bon format d\u0026rsquo;échange  Qui signe ?\n Une autorité payante Let\u0026rsquo;s encrypt Nous-même dans le cadre de l\u0026rsquo;exercice ! Certifcat dit autosigné, ici généré pour localhost, signé par localhost  # On génère une clé privée openssl genrsa 2048 \u0026gt; server.key  # On génère la clé publique associé à la clé privée, et on prépare la demande de certificat openssl req -new -key server.key -out server.csr  \u0026gt; Country Name (2 letter code) [AU]:FR \u0026gt; State or Province Name (full name) [Some-State]:France \u0026gt; Locality Name (eg, city) []:Paris \u0026gt; Organization Name (eg, company) [Internet Widgits Pty Ltd]:Insee \u0026gt; Organizational Unit Name (eg, section) []:CNIP \u0026gt; Common Name (e.g. server FQDN or YOUR name) []:localhost \u0026gt; Email Address []: \u0026gt; Please enter the following 'extra' attributes \u0026gt; to be sent with your certificate request \u0026gt; A challenge password []: \u0026gt; An optional company name []:  # On fait signer la demande par l'AC qui ici est localhost lui-même openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt  # Si on veut transformer en keystore openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12 -passout pass:changeit  Installation sur tomcat # Configuration des ports d\u0026rsquo;écoute : dans le server.xml :\nAjout d\u0026rsquo;un connecteur SSL # \u0026lt;Connector port=\u0026quot;8443\u0026quot; protocol=\u0026quot;org.apache.coyote.http11.Http11NioProtocol\u0026quot; maxThreads=\u0026quot;150\u0026quot; SSLEnabled=\u0026quot;true\u0026quot; scheme=\u0026quot;https\u0026quot; secure=\u0026quot;true\u0026quot; clientAuth=\u0026quot;false\u0026quot; sslProtocol=\u0026quot;TLS\u0026quot; keystoreFile=\u0026quot;${catalina.home}/conf/ssl/server.p12\u0026quot; keystoreType=\u0026quot;pkcs12\u0026quot; keystorePass=\u0026quot;changeit\u0026quot; /\u0026gt;  Configuration de la redirection du connecteur par défaut # On définie le port de redirection dans le cas ou une redirection https est imposée par l\u0026rsquo;application\nCe connecteur existe déjà par défaut, il faut uniquement changer le port de redirection si nécessaire\n\u0026lt;Connector connectionTimeout=\u0026quot;20000\u0026quot; port=\u0026quot;8080\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; redirectPort=\u0026quot;8443\u0026quot;/\u0026gt;  Rendre le https obligatoire # web.xml (Tomcat)\n\u0026lt;security-constraint\u0026gt; \u0026lt;display-name\u0026gt;tout-en-https\u0026lt;/display-name\u0026gt; \u0026lt;web-resource-collection\u0026gt; \u0026lt;web-resource-name\u0026gt;tout\u0026lt;/web-resource-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/web-resource-collection\u0026gt; \u0026lt;user-data-constraint\u0026gt; \u0026lt;transport-guarantee\u0026gt;CONFIDENTIAL\u0026lt;/transport-guarantee\u0026gt; \u0026lt;/user-data-constraint\u0026gt; \u0026lt;/security-constraint\u0026gt;  Spring Security\n@Configuration @EnableWebSecurity public class MySecurityConfiguration { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.requiresChannel().anyRequest().requiresSecure(); } }  TP #  Générer un keystore pour une configuration https de localhost Mettre en place https sur un serveur local Forcer le https sur l\u0026rsquo;application   Vraiment forcer le HTTPS #  Niveau applicatif pour controle éventuellement Niveau Frontal (Load Balancer) : écouter en http sur le port 80 mais uniquement pour rediriger vers https Déclaratif Indiquer au navigateur de ne plsu utiliser que HTTPS : en-tête HSTS  Strict-Transport-Security \u0026quot;max-age=31536000\u0026quot;   Le truststore #  Mon application doit se connecter à une autre application (web-service) Je souhaite que cet appel soit en https (au fond justifié que si la connexion entre les deux serveurs passent par Internet) Lors d\u0026rsquo;une connexion HTTPS, Java vérifie si le certificat distant est valide C\u0026rsquo;est ce que fait le navigateur quand on se connecte à un site Si le certificat n\u0026rsquo;est pas valide (expiré, non associé au domaine, non signé par une autorité de confiance), le navigateur me le signale et je choisit de prendre le risque ou non de me connecter au site. Dans l\u0026rsquo;appli, Java refusera systématiquement la connexion   Le truststore #  Date d\u0026rsquo;expiration, mauvais nom : je ne peux rien faire, il faut que le certificat soit cohérent Autosigné ? Je peux dire à Java que le signataire du certificat est valide, en d\u0026rsquo;autres termes, je lui définis une autorité de confiance (Il existe la possibilité de créer une classe faisant que Java ne fait plus aucun contrôle sur le certificat mais c\u0026rsquo;est mal) Il faut créer un truststore contenant l\u0026rsquo;ensemble des certificats à valider (= ce que l\u0026rsquo;on considère AC)   Le truststore #  Par défaut le trustore chargé est celui de la jvm éxécutant l\u0026rsquo;application (\u0026hellip;.\\mon-jdk\\lib\\security\\cacerts) Le mot de passe par défaut est changeit On peut vouloir un \u0026ldquo;Insee flavored cacert\u0026rdquo; : le cacerts disponible dans la distribution java plus la chaine de certification Insee (AC Racine + AC Subordonnée) Au cas où : certificats AC Insee   Le truststore #  Pour le changer on utilise des paramètres de la JVM :  javax.net.ssl.trustStrore javax.net.ssl.trustStorePassword javax.net.ssl.trustStoreType (par défaut jks)   On crée un nouveau truststore, en pratique on ajoute nos certificats au truststore par défaut   Le truststore #  Créer le truststore  keytool -import -trustcacerts -file server.crt -alias localhost -keystore cacertsperso  Si keytool inconnu : (à ajouter au path pour plus de simplicité)\n\u0026quot;path/to/mon-jdk/bin/keytool.exe\u0026quot; \u0026quot;$JAVA_HOME/bin/keytool.exe\u0026quot;  Crée le truststore si cacertsperso n\u0026rsquo;existe pas encore, ajoute le certificat aux existants s\u0026rsquo;il existe déjà\n Le truststore #  Le déclarer au démarrage :  Paramètres de démarrage    -Djavax.net.ssl.trustStore=\u0026quot;/path/to/cacerts.jks\u0026quot; -Djavax.net.ssl.trustStorePassword=changeit -Djavax.net.ssl.trustStoreType=JKS -Djavax.net.debug=all (UNIQUEMENT pour debugger en cas de problème, c'est TRES verbeux)   Dans le code :  System.setProperty(\u0026quot;javax.net.ssl.trustStore\u0026quot;, \u0026quot;/path/to/cacerts.jks\u0026quot;); System.setProperty(\u0026quot;javax.net.ssl.trustStorePassword\u0026quot;, \u0026quot;changeit\u0026quot;); System.setProperty(\u0026quot;javax.net.ssl.trustStoreType\u0026quot;, \u0026quot;JKS\u0026quot;);   TP #  Créer un truststore incluant le cacert Insee et le certificat généré précédemment Le faire prendre en compte dans l\u0026rsquo;application   Https sur les application javascript #  Fonctionnement proche : réalisé par le F5 en prod, par l\u0026rsquo;apache en dv/qf (mais il n\u0026rsquo;y a pas de tomcat) L\u0026rsquo;application s\u0026rsquo;éxécute chez le client, pour forcer le https, il faut donc raisonner côté client Si l\u0026rsquo;application JS veut s\u0026rsquo;assurer de passer en HTTPS, elle doit vérifier le window.location du client et éventuellement le rediriger.   Https sur les application javascript # if ( typeof window !== 'undefined' \u0026amp;\u0026amp; window.location \u0026amp;\u0026amp; window.location.protocol === 'http:' ) { window.location.href = window.location.href.replace( /^http(?!s)/, 'https' ); }   Https sur les application javascript : développement # Pour lancer une application \u0026ldquo;create-react-app\u0026rdquo; en https en local (par defaut http) :\n Au lieu de npm start Lancer set HTTPS=true\u0026amp;\u0026amp;npm start   Https sur les application javascript : cas du back-end mal signé # Un front-end JavaScript effectue des appels à son backend.\nDans la pratique, c\u0026rsquo;est le navigateur qui effectue ces requetes, et si le certificat du backend ne convient pas au navigateur, la requete va être rejetée.\n Solution 1 : Faire en sort que le backend ait un certificat signé par l\u0026rsquo;Insee Solution 2 : se connecter manuellement une fois au backend, accepter l\u0026rsquo;alerte de sécurité du navigateur  "}).add({id:11,href:"/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()